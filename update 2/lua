if not _G.NEXUS_LOADER_AUTH then
    error("Access denied: Script must be loaded through Nexus loader")
end
_G.NEXUS_LOADER_AUTH = nil

local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/conexion19/NexusLib-v.1.1.1-/refs/heads/main/gffff"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/conexion19/InterfaceManager-NEW-/refs/heads/main/InterfaceManager.lua"))()

local playerName = game:GetService("Players").LocalPlayer.DisplayName
local UserInputService = game:GetService("UserInputService")
local IS_MOBILE = (UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled)
local IS_DESKTOP = (UserInputService.KeyboardEnabled and not UserInputService.TouchEnabled)

local windowSize = IS_MOBILE and UDim2.fromOffset(350, 199) or UDim2.fromOffset(620, 420) -- 620 ширина 

local Window = Fluent:CreateWindow({
    Title = "NEXUS",
    SubTitle = "Marvel Omega",
    Search = false,
    Icon = "",
    TabWidth = 130,
    Size = windowSize,
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.LeftAlt,
    UserInfo = true,
    UserInfoTop = false,
    UserInfoTitle = game:GetService("Players").LocalPlayer.DisplayName,
    UserInfoSubtitle = "User",  
    UserInfoSubtitleColor = Color3.fromRGB(71, 123, 255)
})

local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "user" }),
    Rage = Window:AddTab({ Title = "Rage", Icon = "flame" }),
    Movement = Window:AddTab({ Title = "Movement", Icon = "pencil" }),
    ESP = Window:AddTab({ Title = "ESP", Icon = "eye" }),
    Other = Window:AddTab({ Title = "Other", Icon = "star" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings-2" })
}

local Minimizer

if IS_MOBILE then
    Minimizer = Fluent:CreateMinimizer({
        Icon = "rbxassetid://111390226361567",
        Size = UDim2.fromOffset(22, 22),
        Position = UDim2.new(0, 320, 0, 24),
        Corner = 1,
        Transparency = 1,
        Draggable = true,
        Visible = true
    })
else
    Minimizer = nil  
end

local Options = Fluent.Options

-- Auto Collect 

local autoCollectEnabled = false
local autoCollectConnection = nil
local teleportedModels = {}

local function cleanupDeadReferences()
    for model, _ in pairs(teleportedModels) do
        if not model or not model.Parent then
            teleportedModels[model] = nil
        end
    end
end

local cleanupTask = nil
local function startCleanupTask()
    if cleanupTask then return end
    
    cleanupTask = task.spawn(function()
        while autoCollectEnabled do  
            task.wait(30)
            if autoCollectEnabled then
                cleanupDeadReferences()
            end
        end
        cleanupTask = nil
    end)
end

local function stopCleanupTask()
    if cleanupTask then
        cleanupTask = nil  
    end
end

local function findNamelessModels()
    local namelessModels = {}
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant:IsA("Model") and descendant.Name == "" and not teleportedModels[descendant] then
            table.insert(namelessModels, descendant)
        end
    end
    return namelessModels
end

local function teleportToModel(model)
    local character = game.Players.LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        character.HumanoidRootPart.CFrame = model:GetPivot()
        teleportedModels[model] = true
        return true
    end
    return false
end

local function activateProximityPrompts(model)
    for _, child in pairs(model:GetDescendants()) do
        if child:IsA("ProximityPrompt") then
            child.HoldDuration = 0
            task.wait(0)
            fireproximityprompt(child)
        end
    end
end

local function processModel(model)
    if not autoCollectEnabled then return end
    if teleportedModels[model] then return end
    
    if teleportToModel(model) then
        task.wait(0.2)
        activateProximityPrompts(model)
    end
end

local function autoCollectLoop()
    while autoCollectEnabled do
        task.wait(1)
        local namelessModels = findNamelessModels()
        
        if #namelessModels > 0 then
            for _, model in pairs(namelessModels) do
                if not autoCollectEnabled then break end
                
                processModel(model)
                
                if #namelessModels > 1 then
                    task.wait(1)
                end
            end
        end
    end
end

local function setupAutoCollect()
    if autoCollectConnection then
        autoCollectConnection:Disconnect()
        autoCollectConnection = nil
    end
    
    teleportedModels = {}
    
    autoCollectConnection = game.Workspace.DescendantAdded:Connect(function(descendant)
        if not autoCollectEnabled then return end
        
        if descendant:IsA("Model") and descendant.Name == "" and not teleportedModels[descendant] then
            task.wait(0.8)
            processModel(descendant)
        end
    end)
end

local function toggleAutoCollect(value)
    autoCollectEnabled = value
    
    if autoCollectEnabled then
        teleportedModels = {}
        setupAutoCollect()
        task.spawn(autoCollectLoop)
        startCleanupTask()  
    else
        if autoCollectConnection then
            autoCollectConnection:Disconnect()
            autoCollectConnection = nil
        end
        stopCleanupTask()  
        teleportedModels = {}
    end
end

local function teleportToPosition(position)
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character
    
    if character and character:FindFirstChild("HumanoidRootPart") then
        character.HumanoidRootPart.CFrame = CFrame.new(position)
        return true
    end
    return false
end


local stormFogRemoverEnabled = false
local stormFogRemoverConnection = nil

local function safelyRemoveStormFog(fogPart)
    if fogPart and fogPart:IsA("Part") and fogPart.Name == "Storm_Fog" then
        pcall(function()
            fogPart.Transparency = 1
            fogPart.CanCollide = false
            fogPart.Anchored = true
            
            for _, child in ipairs(fogPart:GetChildren()) do
                task.wait(0.05)
                
                if child:IsA("ParticleEmitter") then
                    child.Enabled = false
                    child.Rate = 0
                elseif child:IsA("Sound") then
                    child:Stop()
                    child.Playing = false
                elseif child:IsA("Fire") or child:IsA("Smoke") then
                    child.Enabled = false
                elseif child:IsA("Decal") then
                    child.Transparency = 1
                elseif child:IsA("SpecialMesh") or child:IsA("MeshPart") then
                    child.Visible = false
                elseif child:IsA("SurfaceGui") or child:IsA("BillboardGui") then
                    child.Enabled = false
                elseif child:IsA("Light") then
                    child.Enabled = false
                end
                
                if child:IsA("BasePart") then
                    child.Transparency = 1
                    child.CanCollide = false
                end
            end
            
            fogPart.CFrame = CFrame.new(0, -10000, 0)
        end)
    end
end

local function processAllStormFog()
    local stormFogs = {}
    
    for _, descendant in pairs(workspace:GetDescendants()) do
        if descendant:IsA("Part") and descendant.Name == "Storm_Fog" then
            table.insert(stormFogs, descendant)
        end
    end
    
    for _, fogPart in ipairs(stormFogs) do
        safelyRemoveStormFog(fogPart)
        task.wait(0.1)
    end
    
    return #stormFogs
end

local function startStormFogRemover()
    if stormFogRemoverConnection then
        stormFogRemoverConnection:Disconnect()
        stormFogRemoverConnection = nil
    end
    
    local processedCount = processAllStormFog()
    if processedCount > 0 then
        print("[Storm_Fog Remover] Обработано " .. processedCount .. " объектов")
    end
    
    stormFogRemoverConnection = workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("Part") and descendant.Name == "Storm_Fog" then
            task.wait(0.2)
            safelyRemoveStormFog(descendant)
        end
    end)
    
    task.spawn(function()
        while stormFogRemoverEnabled do
            processAllStormFog()
            task.wait(1.5)
        end
    end)
end

local function stopStormFogRemover()
    if stormFogRemoverConnection then
        stormFogRemoverConnection:Disconnect()
        stormFogRemoverConnection = nil
    end
end

local function toggleStormFogRemover(value)
    stormFogRemoverEnabled = value
    
    if stormFogRemoverEnabled then
        startStormFogRemover()
    else
        stopStormFogRemover()
    end
end

-- No Cooldown 
local noCooldownEnabled = false
local originalInvokeServer = nil
local originalObfuscatedInvoke = nil
local originalBindRemoteEvent = nil
local cooldownTable = nil

local function enableNoCooldown()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    
    local Player = Players.LocalPlayer
    local Network = require(ReplicatedStorage.Modules.Network)
    
    originalInvokeServer = Network["InvokeServer"]
    
    Network["InvokeServer"] = function(EventName, ...)
        local Result = originalInvokeServer(EventName, ...)
        if EventName == "ActivateAbility" and type(Result) == "table" then
            if Result.Cooldown then
                Result.Cooldown = 0
            end
        end
        return Result
    end
    
    local ObfuscatedKey = "\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141InvokeServer\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141"
    originalObfuscatedInvoke = Network[ObfuscatedKey]
    
    if originalObfuscatedInvoke then
        Network[ObfuscatedKey] = function(EventName, ...)
            local Result = originalObfuscatedInvoke(EventName, ...)
            if EventName == "ActivateAbility" and type(Result) == "table" then
                if Result.Cooldown then
                    Result.Cooldown = 0
                end
            end
            return Result
        end
    end
    
    originalBindRemoteEvent = Network.BindRemoteEvent
    
    Network.BindRemoteEvent = function(EventName, Callback)
        if EventName == "AddCooldown" then
            return originalBindRemoteEvent(EventName, function() end)
        end
        return originalBindRemoteEvent(EventName, Callback)
    end
    
    local Abilities = require(ReplicatedStorage.Modules.Abilities)
    cooldownTable = nil
    
    for Index = 1, 50 do
        local Success, _, Value = pcall(debug.getupvalue, Abilities.ActivateAbility, Index)
        if Success and type(Value) == "table" then
            for _, Entry in pairs(Value) do
                if type(Entry) == "number" and Entry > os.clock() then
                    cooldownTable = Value
                    break
                end
            end
            if cooldownTable then
                break
            end
        end
    end
    
    RunService.Heartbeat:Connect(function()
        if cooldownTable then
            pcall(function()
                table.clear(cooldownTable)
            end)
        end
    end)
end

local function disableNoCooldown()
    if originalInvokeServer then
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Network = require(ReplicatedStorage.Modules.Network)
        Network["InvokeServer"] = originalInvokeServer
    end
    
    if originalObfuscatedInvoke then
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Network = require(ReplicatedStorage.Modules.Network)
        local ObfuscatedKey = "\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141InvokeServer\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141\226\128\141"
        Network[ObfuscatedKey] = originalObfuscatedInvoke
    end
    
    if originalBindRemoteEvent then
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Network = require(ReplicatedStorage.Modules.Network)
        Network.BindRemoteEvent = originalBindRemoteEvent
    end
end

local function toggleNoCooldown(value)
    noCooldownEnabled = value
    
    if noCooldownEnabled then
        enableNoCooldown()
    else
        disableNoCooldown()
    end
end

-- Flight Speed
local flightSpeedEnabled = false
local flightSpeed = 300
local originalFlightSpeed = nil
local originalDampening = nil

local function applyFlightSpeed()
    local Player = game:GetService("Players").LocalPlayer
    local Character = Player.Character
    if not Character then
        return
    end
    
    if flightSpeedEnabled then
      
        if not originalFlightSpeed then
            originalFlightSpeed = Character:GetAttribute("FlightSpeed") or 1
        end
        if not originalDampening then
            originalDampening = Character:GetAttribute("Dampening") or 1.3
        end
        
        Character:SetAttribute("FlightSpeed", flightSpeed)
        Character:SetAttribute("Dampening", 1.3) 
        Character:SetAttribute("FlightTiltMultiplier", 1)
    else
       
        if originalFlightSpeed then
            Character:SetAttribute("FlightSpeed", originalFlightSpeed)
        end
        if originalDampening then
            Character:SetAttribute("Dampening", originalDampening)
        end
    end
end

local function setupFlightSpeed()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    
    local Player = Players.LocalPlayer

    Player.CharacterAdded:Connect(function(Character)
        task.wait(1)

        Character:GetAttributeChangedSignal("FlightSpeed"):Connect(function()
            if flightSpeedEnabled then
                local Current = Character:GetAttribute("FlightSpeed") or 0
                if Current ~= flightSpeed then
                    Character:SetAttribute("FlightSpeed", flightSpeed)
                end
            end
        end)

        Character:GetAttributeChangedSignal("Dampening"):Connect(function()
            if flightSpeedEnabled then
                local Current = Character:GetAttribute("Dampening") or 0
                if Current ~= 1.3 then
                    Character:SetAttribute("Dampening", 1.3)
                end
            end
        end)

        Character:GetAttributeChangedSignal("ApplyingFlightForce"):Connect(function()
            local IsFlying = Character:GetAttribute("ApplyingFlightForce")
            if IsFlying then
                applyFlightSpeed()
            end
        end)

        applyFlightSpeed()
    end)

    RunService.Heartbeat:Connect(function()
        if Player.Character then
            applyFlightSpeed()
        end
    end)

    if Player.Character then
        applyFlightSpeed()
    end
end

local function setFlightSpeed(value)
    flightSpeed = value
    applyFlightSpeed()
end

local function toggleFlightSpeed(value)
    flightSpeedEnabled = value
    
    if flightSpeedEnabled then
        setupFlightSpeed()
    else
        applyFlightSpeed()
    end
end

local silentAimEnabled = false
local silentAimMaxDistance = 500
local silentAimAimPart = "Head"
local originalGetAimPosition = nil

local function getNearestEnemy()
    local Players = game:GetService("Players")
    local CollectionService = game:GetService("CollectionService")
    
    local Player = Players.LocalPlayer
    local NearestEnemy = nil
    local ShortestDistance = silentAimMaxDistance

    local MyCharacter = Player.Character
    if not MyCharacter or not MyCharacter.PrimaryPart then
        return nil
    end

    local MyPosition = MyCharacter.PrimaryPart.Position

    for _, Character in pairs(CollectionService:GetTagged("Character")) do
        if Character ~= MyCharacter and Character:FindFirstChild("Humanoid") then
            local Humanoid = Character.Humanoid
            if Humanoid.Health > 0 then
                local TargetPart = Character:FindFirstChild(silentAimAimPart) or Character.PrimaryPart
                if TargetPart then
                    local Distance = (TargetPart.Position - MyPosition).Magnitude
                    if Distance < ShortestDistance then
                        ShortestDistance = Distance
                        NearestEnemy = TargetPart
                    end
                end
            end
        end
    end

    return NearestEnemy
end

local function enableSilentAim()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    
    local Player = Players.LocalPlayer
    local Camera = workspace.CurrentCamera
    local Aim = require(ReplicatedStorage.Modules.Aim)
    
    originalGetAimPosition = Aim.GetAimPosition
    
    Aim.GetAimPosition = function(...)
        if not silentAimEnabled then
            return originalGetAimPosition(...)
        end

        local NearestEnemy = getNearestEnemy()
        if NearestEnemy then
            return NearestEnemy.Position
        end

        return originalGetAimPosition(...)
    end

    RunService.RenderStepped:Connect(function()
        if not silentAimEnabled or not Player.Character then
            return
        end

        local NearestEnemy = getNearestEnemy()
        if NearestEnemy then
            Player.Character:SetAttribute("AimPosition", NearestEnemy.Position)
            local LookDirection = (NearestEnemy.Position - Camera.CFrame.Position).Unit
            Player.Character:SetAttribute("LookDirection", LookDirection)
        end
    end)
end

local function disableSilentAim()
    if originalGetAimPosition then
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Aim = require(ReplicatedStorage.Modules.Aim)
        Aim.GetAimPosition = originalGetAimPosition
    end
end

local function toggleSilentAim(value)
    silentAimEnabled = value
    
    if silentAimEnabled then
        enableSilentAim()
    else
        disableSilentAim()
    end
end

local function setSilentAimDistance(value)
    silentAimMaxDistance = value
end

-- Noclip
local noclipEnabled = false
local noclipConnections = {}
local currentCharacter = nil

local function applyNoclipToPart(part)
    if part:IsA("BasePart") then
        part.CanCollide = false
    end
end

local function removeNoclipFromPart(part)
    if part:IsA("BasePart") then
        part.CanCollide = true
    end
end

local function setupNoclipForCharacter(character)
    if not character or not noclipEnabled then return end
    
    currentCharacter = character
    
   
    for _, part in ipairs(character:GetDescendants()) do
        applyNoclipToPart(part)
    end
    
    local descendantAddedConnection = character.DescendantAdded:Connect(function(descendant)
        if noclipEnabled then
            applyNoclipToPart(descendant)
        end
    end)
    
    table.insert(noclipConnections, descendantAddedConnection)
    
    local humanoid = character:FindFirstChildWhichIsA("Humanoid")
    if humanoid then
        local stateChangedConnection = humanoid.StateChanged:Connect(function(_, newState)
            if noclipEnabled then
                for _, part in ipairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
        table.insert(noclipConnections, stateChangedConnection)
    end
end

local function cleanupNoclip()
    for _, connection in ipairs(noclipConnections) do
        if connection.Connected then
            connection:Disconnect()
        end
    end
    noclipConnections = {}
    
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character or currentCharacter
    
    if character then
        for _, part in ipairs(character:GetDescendants()) do
            removeNoclipFromPart(part)
        end
    end
    
    currentCharacter = nil
end

local function toggleNoclip(value)
    noclipEnabled = value
    
    if noclipEnabled then
        cleanupNoclip()  
        
        local player = game:GetService("Players").LocalPlayer
        
        local characterAddedConnection = player.CharacterAdded:Connect(function(character)
            cleanupNoclip() 
            task.wait(0.1)  
            setupNoclipForCharacter(character)
        end)
        
        table.insert(noclipConnections, characterAddedConnection)
        
        if player.Character then
            task.wait(0.1)
            setupNoclipForCharacter(player.Character)
        end
    else
        cleanupNoclip()
    end
end

-- Jump Power
local jumpPowerEnabled = false
local jumpPowerValue = 50
local originalJumpPower = nil
local jumpPowerConnection = nil

local function applyJumpPower()
    local Player = game:GetService("Players").LocalPlayer
    local Character = Player.Character
    if not Character then
        return
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    if not Humanoid then
        return
    end
    
    if jumpPowerEnabled then
        if not originalJumpPower then
            originalJumpPower = Humanoid.JumpPower
        end
        Humanoid.JumpPower = jumpPowerValue
    else
        if originalJumpPower then
            Humanoid.JumpPower = originalJumpPower
        end
    end
end

local function setupJumpPower()
    local Players = game:GetService("Players")
    
    local Player = Players.LocalPlayer
    
    local function onCharacterAdded(Character)
        task.wait(0.1) 
        applyJumpPower()
        
        local Humanoid = Character:WaitForChild("Humanoid")
        Humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
            if jumpPowerEnabled then
                local Current = Humanoid.JumpPower
                if Current ~= jumpPowerValue then
                    Humanoid.JumpPower = jumpPowerValue
                end
            end
        end)
    end
    
    Player.CharacterAdded:Connect(onCharacterAdded)
    
    if Player.Character then
        onCharacterAdded(Player.Character)
    end
end

local function setJumpPower(value)
    jumpPowerValue = value
    applyJumpPower()
end

local function toggleJumpPower(value)
    jumpPowerEnabled = value
    
    if jumpPowerEnabled then
        setupJumpPower()
    else
        applyJumpPower()
    end
end

-- Walk Speed
local walkSpeedEnabled = false
local walkSpeedValue = 50
local originalWalkSpeed = nil
local walkSpeedConnection = nil

local function applyWalkSpeed()
    local Player = game:GetService("Players").LocalPlayer
    local Character = Player.Character
    if not Character then
        return
    end
    
    local Humanoid = Character:FindFirstChild("Humanoid")
    if not Humanoid then
        return
    end
    
    if walkSpeedEnabled then
        if not originalWalkSpeed then
            originalWalkSpeed = Humanoid.WalkSpeed
        end
        Humanoid.WalkSpeed = walkSpeedValue
    else
        if originalWalkSpeed then
            Humanoid.WalkSpeed = originalWalkSpeed
        end
    end
end

local function setupWalkSpeed()
    local Players = game:GetService("Players")
    
    local Player = Players.LocalPlayer
    
    local function onCharacterAdded(Character)
        task.wait(0.1) 
        applyWalkSpeed()
        
        local Humanoid = Character:WaitForChild("Humanoid")
        Humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
            if walkSpeedEnabled then
                local Current = Humanoid.WalkSpeed
                if Current ~= walkSpeedValue then
                    Humanoid.WalkSpeed = walkSpeedValue
                end
            end
        end)
    end
    
    Player.CharacterAdded:Connect(onCharacterAdded)
    
    if Player.Character then
        onCharacterAdded(Player.Character)
    end
end

local function setWalkSpeed(value)
    walkSpeedValue = value
    applyWalkSpeed()
end

local function toggleWalkSpeed(value)
    walkSpeedEnabled = value
    
    if walkSpeedEnabled then
        setupWalkSpeed()
    else
        applyWalkSpeed()
    end
end


local function suicide()
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character
    if character then
        local humanoid = character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Health = 0
            Fluent:Notify({
                Title = "Suicide",
                Content = "You have committed suicide.",
                Duration = 3
            })
        end
    end
end

local function rejoinGame()
    local ts = game:GetService("TeleportService")
    local placeId = game.PlaceId
    local jobId = game.JobId
    
    ts:TeleportToPlaceInstance(placeId, jobId, game:GetService("Players").LocalPlayer)
    Fluent:Notify({
        Title = "Rejoin",
        Content = "Rejoining game...",
        Duration = 3
    })
end

local function serverHop()
    local ts = game:GetService("TeleportService")
    local http = game:GetService("HttpService")
    
    Fluent:Notify({
        Title = "Server Hop",
        Content = "Finding new server...",
        Duration = 3
    })
    
    local servers = {}
    local req = http:GetAsync("https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?limit=100")
    local data = http:JSONDecode(req)
    
    for _, server in ipairs(data.data) do
        if server.playing < server.maxPlayers and server.id ~= game.JobId then
            table.insert(servers, server.id)
        end
    end
    
    if #servers > 0 then
        local randomServer = servers[math.random(1, #servers)]
        ts:TeleportToPlaceInstance(game.PlaceId, randomServer)
    else
        Fluent:Notify({
            Title = "Server Hop Error",
            Content = "No available servers found!",
            Duration = 3
        })
    end
end

local Visual = {
    AdvancedESP = {
        settings = {
            enabled = false,
            name = true,
            distance = true,
            healthbar = true,
            box = true,
            boxType = "full",
            bones = true,
            boneColorName = "White",
            tracers = true,
            tracerColorName = "White",
            scale = 1.5,
            healthBarTopColorName = "DarkGreen",
            healthBarMidColorName = "DarkOrange",
            healthBarBottomColorName = "DarkRed",
            stateColorName = "Orange",
            boxOutline = true,
            boxOutlineColorName = "Black",
            boxOutlineThickness = 0.4,
            boxColorName = "White",
            boxFill = true,
            boxFillColorName = "White",
            boxFillTransparency = 0.9,
            healthBarLeftOffset = 10
        },
        colorMap = {
            Red = Color3.fromRGB(255,0,0),
            DarkRed = Color3.fromRGB(100,0,0),
            Green = Color3.fromRGB(0,255,0),
            DarkGreen = Color3.fromRGB(0,80,0),
            Blue = Color3.fromRGB(0,0,255),
            LightBlue = Color3.fromRGB(200,200,255),
            Yellow = Color3.fromRGB(255,255,0),
            Orange = Color3.fromRGB(255,165,0),
            DarkOrange = Color3.fromRGB(140,70,0),
            Purple = Color3.fromRGB(128,0,128),
            White = Color3.fromRGB(255,255,255),
            Black = Color3.fromRGB(0,0,0)
        },
        connections = {},
        espObjects = {},
        playerConnections = {}
    },
    Effects = {
        noShadowEnabled = false,
        noFogEnabled = false,
        fullbrightEnabled = false,
        saturationEnabled = false,
        saturationLevel = 5,
        originalFogEnd = nil,
        originalFogStart = nil,
        originalFogColor = nil,
        originalFogDensity = nil,
        timeChangerEnabled = false,
        originalClockTime = nil        
    }
}

function Visual.ToggleAdvancedESP(enabled)
    Visual.AdvancedESP.settings.enabled = enabled
    
    if enabled then
        Visual.StartAdvancedESP()
    else
        Visual.StopAdvancedESP()
    end
end

function Visual.HideAdvancedESP(plr)
    local d = Visual.AdvancedESP.espObjects[plr]
    if d then
        local drawingObjects = {
            d.BoxFill, d.Name, d.Distance, d.Tracer, d.HealthBg, 
            d.HealthBar, d.HealthMask, d.HealthText, d.Box, d.BoxOutline
        }
        
        for _, obj in ipairs(drawingObjects) do
            if obj then
                pcall(function() 
                    obj.Visible = false 
                end)
            end
        end
        
        for i = 1, 24 do
            if d["HealthStripe"..i] then
                pcall(function() 
                    d["HealthStripe"..i].Visible = false 
                end)
            end
        end
        
        if d.Bones then
            for _, bone in ipairs(d.Bones) do
                if bone then
                    pcall(function() 
                        bone.Visible = false 
                    end)
                end
            end
        end
    end
end

function Visual.CreateAdvancedESP(plr)
    if Visual.AdvancedESP.espObjects[plr] then
        Visual.HideAdvancedESP(plr)
        return Visual.AdvancedESP.espObjects[plr]
    end
    
    local settings = Visual.AdvancedESP.settings
    local colorMap = Visual.AdvancedESP.colorMap
    
    local boneColor = colorMap[settings.boneColorName] or colorMap.White
    local tracerColor = colorMap[settings.tracerColorName] or colorMap.White
    local boxColor = colorMap[settings.boxColorName] or colorMap.White
    local boxOutlineColor = colorMap[settings.boxOutlineColorName] or colorMap.Black
    local boxFillColor = colorMap[settings.boxFillColorName] or colorMap.White
    
    local function create(tp, props)
        local o = Drawing.new(tp)
        for i,v in pairs(props) do o[i]=v end
        return o
    end
    
    local d = {
        Bones = {},
        BoxFill = nil,
        Name = nil,
        Distance = nil,
        Tracer = nil,
        HealthBg = nil,
        HealthBar = nil,
        HealthMask = nil,
        HealthText = nil,
        Box = nil,
        BoxOutline = nil
    }
    
    d.BoxFill = create("Square",{
        Thickness = 0,
        Color = boxFillColor,
        Visible = false,
        Filled = true,
        Transparency = 1 - (settings.boxFillTransparency or 0.9)
    })
    
    d.Name = create("Text",{
        Size = 10,
        Center = true,
        Outline = true,
        Color = Color3.new(1,1,1),
        Visible = false
    })
    
    d.Distance = create("Text",{
        Size = 10,
        Center = true,
        Outline = true,
        Color = Color3.new(0.8,0.8,0.8),
        Visible = false
    })
    
    d.Tracer = create("Line",{
        Thickness = 1.5,
        Color = tracerColor,
        Visible = false
    })
    
    d.HealthBg = Drawing.new("Square")
    d.HealthBg.Visible = false
    d.HealthBg.Filled = true
    d.HealthBg.Color = Color3.new(0,0,0)
    d.HealthBg.Transparency = 1
    
    d.HealthBar = Drawing.new("Square")
    d.HealthBar.Visible = false
    d.HealthBar.Filled = true
    d.HealthBar.Transparency = 1
    
    d.HealthMask = Drawing.new("Square")
    d.HealthMask.Visible = false
    d.HealthMask.Filled = true
    d.HealthMask.Color = Color3.new(0,0,0)
    d.HealthMask.Transparency = 0.3
    
    d.HealthText = create("Text",{
        Size = 9,
        Center = true,
        Outline = true,
        Color = Color3.new(1,1,1),
        Visible = false
    })
    
    d.Box = create("Square", {
        Thickness = 1.7,
        Color = boxColor,
        Visible = false,
        Filled = false
    })
    
    d.BoxOutline = create("Square", {
        Thickness = 1.7 + (settings.boxOutlineThickness or 0.4) * 2,
        Color = boxOutlineColor,
        Visible = false,
        Filled = false
    })
    
    for i = 1, 14 do
        d.Bones[i] = create("Line", {
            Thickness = 1.5,
            Color = boneColor,
            Visible = false
        })
    end
    
    for i = 1, 24 do
        d["HealthStripe"..i] = Drawing.new("Square")
        d["HealthStripe"..i].Visible = false
        d["HealthStripe"..i].Filled = true
        d["HealthStripe"..i].Transparency = 1
    end
    
    Visual.AdvancedESP.espObjects[plr] = d
    
    if not Visual.AdvancedESP.playerConnections[plr] then
        Visual.AdvancedESP.playerConnections[plr] = {}
    end
    
    return d
end

function Visual.SetupPlayerAdvancedESP(plr)
    local localPlayer = game:GetService("Players").LocalPlayer
    if plr == localPlayer then return end
    
    Visual.CreateAdvancedESP(plr)
    
    local function handleCharacterChanged()
        Visual.HideAdvancedESP(plr)
    end
    
    local charAddedConnection = plr.CharacterAdded:Connect(handleCharacterChanged)
    
    local charRemovingConnection = plr.CharacterRemoving:Connect(function()
        Visual.HideAdvancedESP(plr)
    end)
    
    local ancestryChangedConnection = plr.AncestryChanged:Connect(function(_, parent)
        if not parent then
            Visual.HideAdvancedESP(plr)
            if Visual.AdvancedESP.playerConnections[plr] then
                for _, conn in pairs(Visual.AdvancedESP.playerConnections[plr]) do
                    pcall(function() conn:Disconnect() end)
                end
                Visual.AdvancedESP.playerConnections[plr] = nil
            end
        end
    end)
    
    Visual.AdvancedESP.playerConnections[plr] = {
        charAdded = charAddedConnection,
        charRemoving = charRemovingConnection,
        ancestryChanged = ancestryChangedConnection
    }
    
    if plr.Character then
        task.spawn(function()
            wait(0.5)
            if not Visual.AdvancedESP.espObjects[plr] then
                Visual.CreateAdvancedESP(plr)
            end
        end)
    end
end

function Visual.GetHealthGradientColor(y, h)
    local settings = Visual.AdvancedESP.settings
    local colorMap = Visual.AdvancedESP.colorMap
    
    local t = 1 - (y / math.max(h, 1))
    if t >= 0.5 then
        local s = (t - 0.5) * 2
        local midColor = colorMap[settings.healthBarMidColorName] or colorMap.DarkOrange
        local topColor = colorMap[settings.healthBarTopColorName] or colorMap.DarkGreen
        return midColor:Lerp(topColor, s)
    else
        local s = t * 2
        local bottomColor = colorMap[settings.healthBarBottomColorName] or colorMap.DarkRed
        local midColor = colorMap[settings.healthBarMidColorName] or colorMap.DarkOrange
        return bottomColor:Lerp(midColor, s)
    end
end

function Visual.IsR6(char)
    return char:FindFirstChild("Torso") and not char:FindFirstChild("UpperTorso")
end

function Visual.UpdateAdvancedESP()
    local settings = Visual.AdvancedESP.settings
    if not settings.enabled then return end
    
    local Camera = workspace.CurrentCamera
    local camPos = Camera.CFrame.Position
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
    
    for plr, d in pairs(Visual.AdvancedESP.espObjects) do
        if not plr or not plr.Parent then
            Visual.HideAdvancedESP(plr)
            continue
        end
        
        local char = plr.Character
        if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Head") and char:FindFirstChildOfClass("Humanoid") then
            local hum = char:FindFirstChildOfClass("Humanoid")
            
            if hum and hum.Health <= 0 then
                Visual.HideAdvancedESP(plr)
                continue
            end
            
            local root = char.HumanoidRootPart
            local head = char.Head

            local function screenPosOrNil(part)
                if part then
                    local pos, onScreen = Camera:WorldToViewportPoint(part.Position)
                    if onScreen and pos.Z > 0 then 
                        return Vector2.new(pos.X, pos.Y) 
                    end
                end
                return nil
            end

            local headPos, onScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
            local footPos = Camera:WorldToViewportPoint(root.Position - Vector3.new(0, 2.5, 0))

            if onScreen then
                local rawHeight = footPos.Y - headPos.Y
                local height = rawHeight * settings.scale
                local width = (height / 2) * settings.scale
                local x = headPos.X - width / 2
                local y = headPos.Y - (height - rawHeight) / 2

                if d.BoxFill then
                    d.BoxFill.Position = Vector2.new(x, y)
                    d.BoxFill.Size = Vector2.new(width, height)
                    d.BoxFill.Color = Visual.AdvancedESP.colorMap[settings.boxFillColorName] or Visual.AdvancedESP.colorMap.White
                    d.BoxFill.Filled = true
                    d.BoxFill.Transparency = 1 - (settings.boxFillTransparency or 0.9)
                    d.BoxFill.Visible = settings.boxFill and settings.enabled
                end

                if d.Box then
                    d.Box.Position = Vector2.new(x, y)
                    d.Box.Size = Vector2.new(width, height)
                    d.Box.Color = Visual.AdvancedESP.colorMap[settings.boxColorName] or Visual.AdvancedESP.colorMap.White
                    d.Box.Thickness = 1.7
                    d.Box.Visible = settings.box and settings.enabled
                end
                
                if d.BoxOutline then
                    local thickness = settings.boxOutlineThickness or 0.4
                    d.BoxOutline.Position = Vector2.new(x - thickness, y - thickness)
                    d.BoxOutline.Size = Vector2.new(width + thickness * 2, height + thickness * 2)
                    d.BoxOutline.Color = Visual.AdvancedESP.colorMap[settings.boxOutlineColorName] or Visual.AdvancedESP.colorMap.Black
                    d.BoxOutline.Thickness = thickness
                    d.BoxOutline.Visible = settings.box and settings.boxOutline and settings.enabled
                end

                if d.Name then
                    d.Name.Text = plr.Name
                    d.Name.Size = 9.5
                    d.Name.Position = Vector2.new(headPos.X, y - 22)
                    d.Name.Visible = settings.name and settings.enabled
                end

                if d.Distance then
                    local dist = math.floor((root.Position - camPos).Magnitude)
                    d.Distance.Text = dist .. "m"
                    d.Distance.Size = 9.5
                    d.Distance.Position = Vector2.new(headPos.X, y + height + 6)
                    d.Distance.Visible = settings.distance and settings.enabled
                end

                if d.HealthBg and d.HealthBar and d.HealthText then
                    local barX = x - (settings.healthBarLeftOffset or 10)
                    local barY = y
                    local barWidth = 6
                    local barHeight = height
                    
                    d.HealthBg.Position = Vector2.new(barX, barY)
                    d.HealthBg.Size = Vector2.new(barWidth, barHeight)
                    d.HealthBg.Visible = settings.healthbar and settings.enabled
                    
                    if settings.healthbar and settings.enabled then
                        local HEALTH_STRIPES = 24
                        local hpPerc = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
                        
                        for i = 1, HEALTH_STRIPES do
                            local stripe = d["HealthStripe"..i]
                            if stripe then
                                local stripeY = barY + barHeight * (i - 1) / HEALTH_STRIPES
                                local stripeH = barHeight / HEALTH_STRIPES
                                local stripeColor = Visual.GetHealthGradientColor(stripeY - barY, barHeight)
                                
                                stripe.Color = stripeColor
                                stripe.Position = Vector2.new(barX, stripeY)
                                stripe.Size = Vector2.new(barWidth, stripeH)
                                stripe.Visible = (i - 1) / HEALTH_STRIPES < hpPerc
                            end
                        end
                        
                        d.HealthText.Text = tostring(math.floor(hum.Health))
                        d.HealthText.Size = 14
                        d.HealthText.Position = Vector2.new(x - (settings.healthBarLeftOffset or 10) - 14, y + height / 2)
                        d.HealthText.Visible = true
                    else
                        for i = 1, 24 do
                            if d["HealthStripe"..i] then
                                d["HealthStripe"..i].Visible = false
                            end
                        end
                        d.HealthText.Visible = false
                    end
                end

                if d.Bones then
                    local bonesVisible = settings.bones and settings.enabled
                    local bones
                    
                    if Visual.IsR6(char) then
                        bones = {
                            {char:FindFirstChild("Head"), char:FindFirstChild("Torso")},
                            {char:FindFirstChild("Torso"), char:FindFirstChild("Left Arm")},
                            {char:FindFirstChild("Left Arm"), char:FindFirstChild("Left Leg")},
                            {char:FindFirstChild("Torso"), char:FindFirstChild("Right Arm")},
                            {char:FindFirstChild("Right Arm"), char:FindFirstChild("Right Leg")},
                            {char:FindFirstChild("Torso"), char:FindFirstChild("Left Leg")},
                            {char:FindFirstChild("Torso"), char:FindFirstChild("Right Leg")}
                        }
                    else
                        bones = {
                            {char:FindFirstChild("Head"), char:FindFirstChild("Neck")},
                            {char:FindFirstChild("Neck"), char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")},
                            {char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso"), char:FindFirstChild("LeftUpperArm") or char:FindFirstChild("Left Arm")},
                            {char:FindFirstChild("LeftUpperArm") or char:FindFirstChild("Left Arm"), char:FindFirstChild("LeftLowerArm") or char:FindFirstChild("Left Forearm")},
                            {char:FindFirstChild("LeftLowerArm") or char:FindFirstChild("Left Forearm"), char:FindFirstChild("LeftHand") or char:FindFirstChild("Left hand")},
                            {char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso"), char:FindFirstChild("RightUpperArm") or char:FindFirstChild("Right Arm")},
                            {char:FindFirstChild("RightUpperArm") or char:FindFirstChild("Right Arm"), char:FindFirstChild("RightLowerArm") or char:FindFirstChild("Right Forearm")},
                            {char:FindFirstChild("RightLowerArm") or char:FindFirstChild("Right Forearm"), char:FindFirstChild("RightHand") or char:FindFirstChild("Right hand")},
                            {char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso"), char:FindFirstChild("LeftUpperLeg") or char:FindFirstChild("Left Leg")},
                            {char:FindFirstChild("LeftUpperLeg") or char:FindFirstChild("Left Leg"), char:FindFirstChild("LeftLowerLeg") or char:FindFirstChild("Left Shin")},
                            {char:FindFirstChild("LeftLowerLeg") or char:FindFirstChild("Left Shin"), char:FindFirstChild("LeftFoot") or char:FindFirstChild("Left foot")},
                            {char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso"), char:FindFirstChild("RightUpperLeg") or char:FindFirstChild("Right Leg")},
                            {char:FindFirstChild("RightUpperLeg") or char:FindFirstChild("Right Leg"), char:FindFirstChild("RightLowerLeg") or char:FindFirstChild("Right Shin")},
                            {char:FindFirstChild("RightLowerLeg") or char:FindFirstChild("Right Shin"), char:FindFirstChild("RightFoot") or char:FindFirstChild("Right foot")}
                        }
                    end
                    
                    for i = 1, 14 do
                        local line = d.Bones[i]
                        if line and bones[i] and bones[i][1] and bones[i][2] then
                            local p1 = screenPosOrNil(bones[i][1])
                            local p2 = screenPosOrNil(bones[i][2])
                            if p1 and p2 then
                                line.From = p1
                                line.To = p2
                                line.Color = Visual.AdvancedESP.colorMap[settings.boneColorName] or Visual.AdvancedESP.colorMap.White
                                line.Visible = bonesVisible
                            else
                                line.Visible = false
                            end
                        elseif line then
                            line.Visible = false
                        end
                    end
                end

                if d.Tracer then
                    local rootPos2D = Vector2.new(headPos.X, headPos.Y)
                    d.Tracer.From = screenCenter
                    d.Tracer.To = rootPos2D
                    d.Tracer.Color = Visual.AdvancedESP.colorMap[settings.tracerColorName] or Visual.AdvancedESP.colorMap.White
                    d.Tracer.Visible = settings.tracers and settings.enabled
                end
            else
                Visual.HideAdvancedESP(plr)
            end
        else
            Visual.HideAdvancedESP(plr)
        end
    end
end

function Visual.StartAdvancedESP()
    if Visual.AdvancedESP.connections.renderStepped then
        Visual.AdvancedESP.connections.renderStepped:Disconnect()
        Visual.AdvancedESP.connections.renderStepped = nil
    end
    
    Visual.AdvancedESP.connections.playerAdded = game:GetService("Players").PlayerAdded:Connect(function(plr)
        if plr ~= game:GetService("Players").LocalPlayer then
            Visual.SetupPlayerAdvancedESP(plr)
        end
    end)
    
    Visual.AdvancedESP.connections.playerRemoving = game:GetService("Players").PlayerRemoving:Connect(function(plr)
        Visual.HideAdvancedESP(plr)
        if Visual.AdvancedESP.playerConnections[plr] then
            for _, conn in pairs(Visual.AdvancedESP.playerConnections[plr]) do
                pcall(function() conn:Disconnect() end)
            end
            Visual.AdvancedESP.playerConnections[plr] = nil
        end
    end)
    
    for _, plr in pairs(game:GetService("Players"):GetPlayers()) do
        if plr ~= game:GetService("Players").LocalPlayer then
            Visual.SetupPlayerAdvancedESP(plr)
        end
    end
    
    Visual.AdvancedESP.connections.renderStepped = game:GetService("RunService").RenderStepped:Connect(function()
        Visual.UpdateAdvancedESP()
    end)
end

function Visual.StopAdvancedESP()
    for _, connection in pairs(Visual.AdvancedESP.connections) do
        pcall(function() connection:Disconnect() end)
    end
    Visual.AdvancedESP.connections = {}
    
    for plr, _ in pairs(Visual.AdvancedESP.espObjects) do
        Visual.HideAdvancedESP(plr)
    end
    
    for plr, connections in pairs(Visual.AdvancedESP.playerConnections) do
        for _, conn in pairs(connections) do
            pcall(function() conn:Disconnect() end)
        end
    end
    Visual.AdvancedESP.playerConnections = {}
end

function Visual.ToggleNoShadow(enabled)
    Visual.Effects.noShadowEnabled = enabled
    if enabled then
        for _, light in ipairs(game:GetService("Lighting"):GetDescendants()) do 
            if light:IsA("Light") then 
                light.Shadows = false 
            end 
        end
        game:GetService("Lighting").GlobalShadows = false
    else
        for _, light in ipairs(game:GetService("Lighting"):GetDescendants()) do 
            if light:IsA("Light") then 
                light.Shadows = true 
            end 
        end
        game:GetService("Lighting").GlobalShadows = true
    end
end

function Visual.ToggleNoFog(enabled)
    Visual.Effects.noFogEnabled = enabled
    
    if enabled then
        local lighting = game:GetService("Lighting")
        
        if not Visual.Effects.originalFogEnd then
            Visual.Effects.originalFogEnd = lighting.FogEnd
            Visual.Effects.originalFogStart = lighting.FogStart
            Visual.Effects.originalFogColor = lighting.FogColor
            Visual.Effects.originalFogDensity = lighting.FogDensity
        end
        
        lighting.FogEnd = 10000000
        lighting.FogStart = 0
        lighting.FogDensity = 0
    else
        local lighting = game:GetService("Lighting")
        
        if Visual.Effects.originalFogEnd then
            lighting.FogEnd = Visual.Effects.originalFogEnd
            lighting.FogStart = Visual.Effects.originalFogStart
            lighting.FogColor = Visual.Effects.originalFogColor
            lighting.FogDensity = Visual.Effects.originalFogDensity
            
            Visual.Effects.originalFogEnd = nil
            Visual.Effects.originalFogStart = nil
            Visual.Effects.originalFogColor = nil
            Visual.Effects.originalFogDensity = nil
        end
    end
end

function Visual.ToggleSaturation(enabled)
    Visual.Effects.saturationEnabled = enabled
    
    if enabled then
        Visual.UpdateSaturation()
    else
        local lighting = game:GetService("Lighting")
        
        local colorCorrection = lighting:FindFirstChild("SaturationEffect")
        if colorCorrection then
            colorCorrection:Destroy()
        end
    end
end

function Visual.UpdateSaturation()
    if not Visual.Effects.saturationEnabled then return end
    
    local lighting = game:GetService("Lighting")
    
    local colorCorrection = lighting:FindFirstChild("SaturationEffect")
    if not colorCorrection then
        colorCorrection = Instance.new("ColorCorrectionEffect")
        colorCorrection.Name = "SaturationEffect"
        colorCorrection.Parent = lighting
    end
    
    local saturationValue = Visual.Effects.saturationLevel / 5
    colorCorrection.Saturation = saturationValue
end

function Visual.ToggleTimeChanger(enabled)
    Visual.Effects.timeChangerEnabled = enabled
    
    if enabled then
        if not Visual.Effects.originalClockTime then
            Visual.Effects.originalClockTime = game:GetService("Lighting").ClockTime
        end
        
        local currentTime = Options.TimeValue and Options.TimeValue.Value or 14
        game:GetService("Lighting").ClockTime = currentTime
    else
        if Visual.Effects.originalClockTime then
            game:GetService("Lighting").ClockTime = Visual.Effects.originalClockTime
        end
    end
end

function Visual.SetTime(time)
    game:GetService("Lighting").ClockTime = time
end

function Visual.Cleanup()
    Visual.StopAdvancedESP()
    Visual.ToggleNoShadow(false)
    Visual.ToggleNoFog(false)
    Visual.ToggleSaturation(false)
    Visual.ToggleTimeChanger(false)

    for _, connection in pairs(Visual.AdvancedESP.connections) do
        pcall(function() connection:Disconnect() end)
    end
    Visual.AdvancedESP.connections = {}
end

do

Tabs.Main:AddSection("Main")

Tabs.Main:AddParagraph({
    Icon = "key",
    Title = string.format("Hello, %s!", playerName),
    Content = "Thank you for being with us!\nEnjoy using the script!"
 })

    local AutoCollectToggle = Tabs.Main:AddToggle("AutoCollectToggle", {Title = "Auto Collect", Default = false })
    AutoCollectToggle:OnChanged(function()
        toggleAutoCollect(Options.AutoCollectToggle.Value)
    end)
    Options.AutoCollectToggle:SetValue(false)
    
    
    local TeleportDropdown = Tabs.Main:AddDropdown("TeleportDropdown", {
        Title = "Teleport to Stone",
        Values = {"--", "Time Stone", "Power Stone", "DarkHold"},
        Multi = false,
        Default = "--",
    })
    
    TeleportDropdown:OnChanged(function(value)
        if value ~= "--" then
            local position
            local stoneName = ""
            
            if value == "Time Stone" then
                position = Vector3.new(2374.59, 694.15, 656.16)
                stoneName = "Time Stone"
            elseif value == "Power Stone" then
                position = Vector3.new(-346.44, 699.48, 1900.34)
                stoneName = "Power Stone"
            elseif value == "DarkHold" then
                position = Vector3.new(-2819.78, 1050.55, 650.29)
                stoneName = "DarkHold"
            end
            
            if position then
                local success = teleportToPosition(position)
                if success then
                    Fluent:Notify({
                        Title = "Teleport",
                        Content = "Teleported to " .. stoneName,
                        Duration = 3
                    })
                else
                    Fluent:Notify({
                        Title = "Teleport Error",
                        Content = "Failed to teleport to " .. stoneName,
                        Duration = 3
                    })
                end
            end
 
            task.wait(0.1)
            TeleportDropdown:SetValue("--")
        end
    end)
end

do
    Tabs.Rage:AddSection("Rage")
    
    local StormFogToggle = Tabs.Rage:AddToggle("StormFogToggle", {
        Title = "No Fog (Storm)", 
        Description = "Remove storm fog effects",
        Default = false
    })
    
    StormFogToggle:OnChanged(function()
        toggleStormFogRemover(Options.StormFogToggle.Value)
    end)
    
    
    local FlightSpeedToggle = Tabs.Rage:AddToggle("FlightSpeedToggle", {
        Title = "Flight Speed", 
        Description = "Modify flight speed",
        Default = false
    })
    
    FlightSpeedToggle:OnChanged(function()
        toggleFlightSpeed(Options.FlightSpeedToggle.Value)
    end)
    
    local FlightSpeedSlider = Tabs.Rage:AddSlider("FlightSpeedValue", {
        Title = "Flight Speed", 
        Description = "Adjust flight speed (1-300)",
        Default = 300,
        Min = 1,
        Max = 300,
        Rounding = 0,
        Callback = function(value)
            setFlightSpeed(value)
        end
    })
    
    local SilentAimToggle = Tabs.Rage:AddToggle("SilentAimToggle", {
        Title = "Silent Aim", 
        Description = "Enable silent aim",
        Default = false
    })
    
    SilentAimToggle:OnChanged(function()
        toggleSilentAim(Options.SilentAimToggle.Value)
    end)
    
    local SilentAimDistanceSlider = Tabs.Rage:AddSlider("SilentAimDistance", {
        Title = "Aim Distance", 
        Description = "Adjust silent aim distance (100-1200)",
        Default = 500,
        Min = 100,
        Max = 1200,
        Rounding = 0,
        Callback = function(value)
            setSilentAimDistance(value)
        end
    })
    
    local NoCooldownToggle = Tabs.Rage:AddToggle("NoCooldownToggle", {
        Title = "No Cooldown [Beta]", 
        Description = "Remove ability cooldowns",
        Default = false
    })
    
    NoCooldownToggle:OnChanged(function()
        toggleNoCooldown(Options.NoCooldownToggle.Value)
    end)
end

do
    Tabs.Movement:AddSection("Movement")
    
    local NoclipToggle = Tabs.Movement:AddToggle("NoclipToggle", {
        Title = "Noclip", 
        Description = "Walk through walls",
        Default = false
    })
    
    NoclipToggle:OnChanged(function()
        toggleNoclip(Options.NoclipToggle.Value)
    end)
    
    local JumpPowerToggle = Tabs.Movement:AddToggle("JumpPowerToggle", {
        Title = "Jump Power", 
        Description = "Modify jump height",
        Default = false
    })
    
    JumpPowerToggle:OnChanged(function()
        toggleJumpPower(Options.JumpPowerToggle.Value)
    end)
    
    local JumpPowerSlider = Tabs.Movement:AddSlider("JumpPowerValue", {
        Title = "Jump Height", 
        Description = "Adjust jump power (0-500)",
        Default = 50,
        Min = 0,
        Max = 500,
        Rounding = 0,
        Callback = function(value)
            setJumpPower(value)
        end
    })
    
    local WalkSpeedToggle = Tabs.Movement:AddToggle("WalkSpeedToggle", {
        Title = "Walk Speed", 
        Description = "Modify movement speed",
        Default = false
    })
    
    WalkSpeedToggle:OnChanged(function()
        toggleWalkSpeed(Options.WalkSpeedToggle.Value)
    end)
    
    local WalkSpeedSlider = Tabs.Movement:AddSlider("WalkSpeedValue", {
        Title = "Speed Value", 
        Description = "Adjust walk speed (0-1000)",
        Default = 50,
        Min = 0,
        Max = 1000,
        Rounding = 0,
        Callback = function(value)
            setWalkSpeed(value)
        end
    })
end

do
    Tabs.Other:AddSection("Other")
    
    Tabs.Other:AddButton({
        Title = "Suicide",
        Description = "Kill your character",
        Callback = function()
            suicide()
        end
    })
    
    Tabs.Other:AddButton({
        Title = "Rejoin Game",
        Description = "Rejoins the current game server",
        Callback = function()
            rejoinGame()
        end
    })
    
    Tabs.Other:AddButton({
        Title = "Server Hop",
        Description = "Joins a new random server",
        Callback = function()
            serverHop()
        end
    })
end

do
    Tabs.ESP:AddSection("Visual & ESP")
    
    local NoShadowToggle = Tabs.ESP:AddToggle("NoShadow", {
        Title = "No Shadow", 
        Description = "Remove shadows in the game", 
        Default = false
    })
    NoShadowToggle:OnChanged(function(v) Visual.ToggleNoShadow(v) end)

    local NoFogToggle = Tabs.ESP:AddToggle("NoFog", {
        Title = "No Fog", 
        Description = "Remove fog", 
        Default = false
    })
    
    NoFogToggle:OnChanged(function(v) 
        pcall(function()
            Visual.ToggleNoFog(v)
        end)
    end)

    local SaturationToggle = Tabs.ESP:AddToggle("Saturation", {
        Title = "Saturation", 
        Description = "Increase color saturation", 
        Default = false
    })
    SaturationToggle:OnChanged(function(v) 
        Visual.ToggleSaturation(v)
    end)

    local SaturationSlider = Tabs.ESP:AddSlider("SaturationLevel", {
        Title = "Saturation Level", 
        Description = "Adjust saturation intensity",
        Default = 5,
        Min = 1,
        Max = 10,
        Rounding = 0,
        Callback = function(value)
            Visual.Effects.saturationLevel = value
            if Visual.Effects.saturationEnabled then
                Visual.UpdateSaturation()
            end
        end
    })

    local TimeChangerToggle = Tabs.ESP:AddToggle("TimeChanger", {
        Title = "Time Changer", 
        Description = "Change the time of day", 
        Default = false
    })

    local TimeSlider = Tabs.ESP:AddSlider("TimeValue", {
        Title = "Time of Day", 
        Description = "Change the time of day (24 hours)",
        Default = 14,
        Min = 0,
        Max = 24,
        Rounding = 1,
        Callback = function(value)
            if Options.TimeChanger and Options.TimeChanger.Value then
                Visual.SetTime(value)
            end
        end
    })

    TimeChangerToggle:OnChanged(function(v)
        Visual.ToggleTimeChanger(v)
    end)

    task.spawn(function()
        while true do
            task.wait(1)
            if Options.TimeChanger and Options.TimeChanger.Value then
                local currentTime = Options.TimeValue.Value
                Visual.SetTime(currentTime)
            end
        end
    end)

    Tabs.ESP:AddSection("OFF / ON ESP ALL")
    
    local AdvancedESPToggle = Tabs.ESP:AddToggle("AdvancedESP", {
        Title = "OFF / ON ESP ALL", 
        Description = "Enable advanced player ESP system", 
        Default = false
    })
    AdvancedESPToggle:OnChanged(function(v)
        Visual.ToggleAdvancedESP(v)
    end)

    local ESPBoxToggle = Tabs.ESP:AddToggle("ESPBox", {
        Title = "Player Boxes", 
        Description = "Show/hide player boxes", 
        Default = true
    })
    ESPBoxToggle:OnChanged(function(v)
        Visual.AdvancedESP.settings.box = v
    end)

    local ESPNamesToggle = Tabs.ESP:AddToggle("ESPNames", {
        Title = "Player Names", 
        Description = "Show/hide player names", 
        Default = true
    })
    ESPNamesToggle:OnChanged(function(v)
        Visual.AdvancedESP.settings.name = v
    end)

    local ESPHealthBarToggle = Tabs.ESP:AddToggle("ESPHealthBar", {
        Title = "Health Bar", 
        Description = "Show/hide health bar", 
        Default = true
    })
    ESPHealthBarToggle:OnChanged(function(v)
        Visual.AdvancedESP.settings.healthbar = v
    end)

    local ESPDistanceToggle = Tabs.ESP:AddToggle("ESPDistance", {
        Title = "Distance", 
        Description = "Show/hide distance to players", 
        Default = true
    })
    ESPDistanceToggle:OnChanged(function(v)
        Visual.AdvancedESP.settings.distance = v
    end)

    local ESPBoxFillToggle = Tabs.ESP:AddToggle("ESPBoxFill", {
        Title = "Filled Box", 
        Description = "Show/hide filled boxes", 
        Default = true
    })
    ESPBoxFillToggle:OnChanged(function(v)
        Visual.AdvancedESP.settings.boxFill = v
    end)

    local ESPTracersToggle = Tabs.ESP:AddToggle("ESPTracers", {
        Title = "Tracers", 
        Description = "Show/hide tracers to players", 
        Default = true
    })
    ESPTracersToggle:OnChanged(function(v)
        Visual.AdvancedESP.settings.tracers = v
    end)

    local ESPBonesToggle = Tabs.ESP:AddToggle("ESPBones", {
        Title = "Player Bones", 
        Description = "Show/hide player bones", 
        Default = true
    })
    ESPBonesToggle:OnChanged(function(v)
        Visual.AdvancedESP.settings.bones = v
    end)
end

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")  
InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)

Fluent:Notify({
    Title = "Fluent",
    Content = "The script has been loaded.",
    Duration = 4.5
})

SaveManager:LoadAutoloadConfig()

game:GetService("Players").LocalPlayer.AncestryChanged:Connect(function(_, parent)
    if not parent then
        Visual.Cleanup()
        toggleAutoCollect(false)
        toggleStormFogRemover(false)
        toggleNoCooldown(false)
        toggleFlightSpeed(false)
        toggleSilentAim(false)
        toggleJumpPower(false)
        toggleWalkSpeed(false)
        toggleNoclip(false)
    end
end)
